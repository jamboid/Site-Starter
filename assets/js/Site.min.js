/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 0.6.11
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */

/*jslint browser:true, node:true*/
/*global define, Event, Node*/


/**
 * Instantiate fast-clicking listeners on the specificed layer.
 *
 * @constructor
 * @param {Element} layer The layer to listen on
 */
function FastClick(layer) {
  'use strict';
  var oldOnClick, self = this;


  /**
   * Whether a click is currently being tracked.
   *
   * @type boolean
   */
  this.trackingClick = false;


  /**
   * Timestamp for when when click tracking started.
   *
   * @type number
   */
  this.trackingClickStart = 0;


  /**
   * The element being tracked for a click.
   *
   * @type EventTarget
   */
  this.targetElement = null;


  /**
   * X-coordinate of touch start event.
   *
   * @type number
   */
  this.touchStartX = 0;


  /**
   * Y-coordinate of touch start event.
   *
   * @type number
   */
  this.touchStartY = 0;


  /**
   * ID of the last touch, retrieved from Touch.identifier.
   *
   * @type number
   */
  this.lastTouchIdentifier = 0;


  /**
   * Touchmove boundary, beyond which a click will be cancelled.
   *
   * @type number
   */
  this.touchBoundary = 10;


  /**
   * The FastClick layer.
   *
   * @type Element
   */
  this.layer = layer;

  if (!layer || !layer.nodeType) {
    throw new TypeError('Layer must be a document node');
  }

  /** @type function() */
  this.onClick = function() { return FastClick.prototype.onClick.apply(self, arguments); };

  /** @type function() */
  this.onMouse = function() { return FastClick.prototype.onMouse.apply(self, arguments); };

  /** @type function() */
  this.onTouchStart = function() { return FastClick.prototype.onTouchStart.apply(self, arguments); };

  /** @type function() */
  this.onTouchMove = function() { return FastClick.prototype.onTouchMove.apply(self, arguments); };

  /** @type function() */
  this.onTouchEnd = function() { return FastClick.prototype.onTouchEnd.apply(self, arguments); };

  /** @type function() */
  this.onTouchCancel = function() { return FastClick.prototype.onTouchCancel.apply(self, arguments); };

  if (FastClick.notNeeded(layer)) {
    return;
  }

  // Set up event handlers as required
  if (this.deviceIsAndroid) {
    layer.addEventListener('mouseover', this.onMouse, true);
    layer.addEventListener('mousedown', this.onMouse, true);
    layer.addEventListener('mouseup', this.onMouse, true);
  }

  layer.addEventListener('click', this.onClick, true);
  layer.addEventListener('touchstart', this.onTouchStart, false);
  layer.addEventListener('touchmove', this.onTouchMove, false);
  layer.addEventListener('touchend', this.onTouchEnd, false);
  layer.addEventListener('touchcancel', this.onTouchCancel, false);

  // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
  // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
  // layer when they are cancelled.
  if (!Event.prototype.stopImmediatePropagation) {
    layer.removeEventListener = function(type, callback, capture) {
      var rmv = Node.prototype.removeEventListener;
      if (type === 'click') {
        rmv.call(layer, type, callback.hijacked || callback, capture);
      } else {
        rmv.call(layer, type, callback, capture);
      }
    };

    layer.addEventListener = function(type, callback, capture) {
      var adv = Node.prototype.addEventListener;
      if (type === 'click') {
        adv.call(layer, type, callback.hijacked || (callback.hijacked = function(event) {
          if (!event.propagationStopped) {
            callback(event);
          }
        }), capture);
      } else {
        adv.call(layer, type, callback, capture);
      }
    };
  }

  // If a handler is already declared in the element's onclick attribute, it will be fired before
  // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
  // adding it as listener.
  if (typeof layer.onclick === 'function') {

    // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
    // - the old one won't work if passed to addEventListener directly.
    oldOnClick = layer.onclick;
    layer.addEventListener('click', function(event) {
      oldOnClick(event);
    }, false);
    layer.onclick = null;
  }
}


/**
 * Android requires exceptions.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0;


/**
 * iOS requires exceptions.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent);


/**
 * iOS 4 requires an exception for select elements.
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOS4 = FastClick.prototype.deviceIsIOS && (/OS 4_\d(_\d)?/).test(navigator.userAgent);


/**
 * iOS 6.0(+?) requires the target element to be manually derived
 *
 * @type boolean
 */
FastClick.prototype.deviceIsIOSWithBadTarget = FastClick.prototype.deviceIsIOS && (/OS ([6-9]|\d{2})_\d/).test(navigator.userAgent);


/**
 * Determine whether a given element requires a native click.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element needs a native click
 */
FastClick.prototype.needsClick = function(target) {
  'use strict';
  switch (target.nodeName.toLowerCase()) {

  // Don't send a synthetic click to disabled inputs (issue #62)
  case 'button':
  case 'select':
  case 'textarea':
    if (target.disabled) {
      return true;
    }

    break;
  case 'input':

    // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
    if ((this.deviceIsIOS && target.type === 'file') || target.disabled) {
      return true;
    }

    break;
  case 'label':
  case 'video':
    return true;
  }

  return (/\bneedsclick\b/).test(target.className);
};


/**
 * Determine whether a given element requires a call to focus to simulate click into element.
 *
 * @param {EventTarget|Element} target Target DOM element
 * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
 */
FastClick.prototype.needsFocus = function(target) {
  'use strict';
  switch (target.nodeName.toLowerCase()) {
  case 'textarea':
    return true;
  case 'select':
    return !this.deviceIsAndroid;
  case 'input':
    switch (target.type) {
    case 'button':
    case 'checkbox':
    case 'file':
    case 'image':
    case 'radio':
    case 'submit':
      return false;
    }

    // No point in attempting to focus disabled inputs
    return !target.disabled && !target.readOnly;
  default:
    return (/\bneedsfocus\b/).test(target.className);
  }
};


/**
 * Send a click event to the specified element.
 *
 * @param {EventTarget|Element} targetElement
 * @param {Event} event
 */
FastClick.prototype.sendClick = function(targetElement, event) {
  'use strict';
  var clickEvent, touch;

  // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)
  if (document.activeElement && document.activeElement !== targetElement) {
    document.activeElement.blur();
  }

  touch = event.changedTouches[0];

  // Synthesise a click event, with an extra attribute so it can be tracked
  clickEvent = document.createEvent('MouseEvents');
  clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
  clickEvent.forwardedTouchEvent = true;
  targetElement.dispatchEvent(clickEvent);
};

FastClick.prototype.determineEventType = function(targetElement) {
  'use strict';

  //Issue #159: Android Chrome Select Box does not open with a synthetic click event
  if (this.deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
    return 'mousedown';
  }

  return 'click';
};


/**
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.focus = function(targetElement) {
  'use strict';
  var length;

  // Issue #160: on iOS 7, some input elements (e.g. date datetime) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.
  if (this.deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time') {
    length = targetElement.value.length;
    targetElement.setSelectionRange(length, length);
  } else {
    targetElement.focus();
  }
};


/**
 * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
 *
 * @param {EventTarget|Element} targetElement
 */
FastClick.prototype.updateScrollParent = function(targetElement) {
  'use strict';
  var scrollParent, parentElement;

  scrollParent = targetElement.fastClickScrollParent;

  // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
  // target element was moved to another parent.
  if (!scrollParent || !scrollParent.contains(targetElement)) {
    parentElement = targetElement;
    do {
      if (parentElement.scrollHeight > parentElement.offsetHeight) {
        scrollParent = parentElement;
        targetElement.fastClickScrollParent = parentElement;
        break;
      }

      parentElement = parentElement.parentElement;
    } while (parentElement);
  }

  // Always update the scroll top tracker if possible.
  if (scrollParent) {
    scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
  }
};


/**
 * @param {EventTarget} targetElement
 * @returns {Element|EventTarget}
 */
FastClick.prototype.getTargetElementFromEventTarget = function(eventTarget) {
  'use strict';

  // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
  if (eventTarget.nodeType === Node.TEXT_NODE) {
    return eventTarget.parentNode;
  }

  return eventTarget;
};


/**
 * On touch start, record the position and scroll offset.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchStart = function(event) {
  'use strict';
  var targetElement, touch, selection;

  // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).
  if (event.targetTouches.length > 1) {
    return true;
  }

  targetElement = this.getTargetElementFromEventTarget(event.target);
  touch = event.targetTouches[0];

  if (this.deviceIsIOS) {

    // Only trusted events will deselect text on iOS (issue #49)
    selection = window.getSelection();
    if (selection.rangeCount && !selection.isCollapsed) {
      return true;
    }

    if (!this.deviceIsIOS4) {

      // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
      // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
      // with the same identifier as the touch event that previously triggered the click that triggered the alert.
      // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
      // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
      if (touch.identifier === this.lastTouchIdentifier) {
        event.preventDefault();
        return false;
      }

      this.lastTouchIdentifier = touch.identifier;

      // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
      // 1) the user does a fling scroll on the scrollable layer
      // 2) the user stops the fling scroll with another tap
      // then the event.target of the last 'touchend' event will be the element that was under the user's finger
      // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
      // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).
      this.updateScrollParent(targetElement);
    }
  }

  this.trackingClick = true;
  this.trackingClickStart = event.timeStamp;
  this.targetElement = targetElement;

  this.touchStartX = touch.pageX;
  this.touchStartY = touch.pageY;

  // Prevent phantom clicks on fast double-tap (issue #36)
  if ((event.timeStamp - this.lastClickTime) < 200) {
    event.preventDefault();
  }

  return true;
};


/**
 * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.touchHasMoved = function(event) {
  'use strict';
  var touch = event.changedTouches[0], boundary = this.touchBoundary;

  if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
    return true;
  }

  return false;
};


/**
 * Update the last position.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchMove = function(event) {
  'use strict';
  if (!this.trackingClick) {
    return true;
  }

  // If the touch has moved, cancel the click tracking
  if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
    this.trackingClick = false;
    this.targetElement = null;
  }

  return true;
};


/**
 * Attempt to find the labelled control for the given label element.
 *
 * @param {EventTarget|HTMLLabelElement} labelElement
 * @returns {Element|null}
 */
FastClick.prototype.findControl = function(labelElement) {
  'use strict';

  // Fast path for newer browsers supporting the HTML5 control attribute
  if (labelElement.control !== undefined) {
    return labelElement.control;
  }

  // All browsers under test that support touch events also support the HTML5 htmlFor attribute
  if (labelElement.htmlFor) {
    return document.getElementById(labelElement.htmlFor);
  }

  // If no for attribute exists, attempt to retrieve the first labellable descendant element
  // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label
  return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
};


/**
 * On touch end, determine whether to send a click event at once.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onTouchEnd = function(event) {
  'use strict';
  var forElement, trackingClickStart, targetTagName, scrollParent, touch, targetElement = this.targetElement;

  if (!this.trackingClick) {
    return true;
  }

  // Prevent phantom clicks on fast double-tap (issue #36)
  if ((event.timeStamp - this.lastClickTime) < 200) {
    this.cancelNextClick = true;
    return true;
  }

  // Reset to prevent wrong click cancel on input (issue #156).
  this.cancelNextClick = false;

  this.lastClickTime = event.timeStamp;

  trackingClickStart = this.trackingClickStart;
  this.trackingClick = false;
  this.trackingClickStart = 0;

  // On some iOS devices, the targetElement supplied with the event is invalid if the layer
  // is performing a transition or scroll, and has to be re-detected manually. Note that
  // for this to function correctly, it must be called *after* the event target is checked!
  // See issue #57; also filed as rdar://13048589 .
  if (this.deviceIsIOSWithBadTarget) {
    touch = event.changedTouches[0];

    // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null
    targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
    targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
  }

  targetTagName = targetElement.tagName.toLowerCase();
  if (targetTagName === 'label') {
    forElement = this.findControl(targetElement);
    if (forElement) {
      this.focus(targetElement);
      if (this.deviceIsAndroid) {
        return false;
      }

      targetElement = forElement;
    }
  } else if (this.needsFocus(targetElement)) {

    // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
    // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
    if ((event.timeStamp - trackingClickStart) > 100 || (this.deviceIsIOS && window.top !== window && targetTagName === 'input')) {
      this.targetElement = null;
      return false;
    }

    this.focus(targetElement);

    // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
    if (!this.deviceIsIOS4 || targetTagName !== 'select') {
      this.targetElement = null;
      event.preventDefault();
    }

    return false;
  }

  if (this.deviceIsIOS && !this.deviceIsIOS4) {

    // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
    // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
    scrollParent = targetElement.fastClickScrollParent;
    if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
      return true;
    }
  }

  // Prevent the actual click from going though - unless the target node is marked as requiring
  // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.
  if (!this.needsClick(targetElement)) {
    event.preventDefault();
    this.sendClick(targetElement, event);
  }

  return false;
};


/**
 * On touch cancel, stop tracking the click.
 *
 * @returns {void}
 */
FastClick.prototype.onTouchCancel = function() {
  'use strict';
  this.trackingClick = false;
  this.targetElement = null;
};


/**
 * Determine mouse events which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onMouse = function(event) {
  'use strict';

  // If a target element was never set (because a touch event was never fired) allow the event
  if (!this.targetElement) {
    return true;
  }

  if (event.forwardedTouchEvent) {
    return true;
  }

  // Programmatically generated events targeting a specific element should be permitted
  if (!event.cancelable) {
    return true;
  }

  // Derive and check the target element to see whether the mouse event needs to be permitted;
  // unless explicitly enabled, prevent non-touch click events from triggering actions,
  // to prevent ghost/doubleclicks.
  if (!this.needsClick(this.targetElement) || this.cancelNextClick) {

    // Prevent any user-added listeners declared on FastClick element from being fired.
    if (event.stopImmediatePropagation) {
      event.stopImmediatePropagation();
    } else {

      // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
      event.propagationStopped = true;
    }

    // Cancel the event
    event.stopPropagation();
    event.preventDefault();

    return false;
  }

  // If the mouse event is permitted, return true for the action to go through.
  return true;
};


/**
 * On actual clicks, determine whether this is a touch-generated click, a click action occurring
 * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
 * an actual click which should be permitted.
 *
 * @param {Event} event
 * @returns {boolean}
 */
FastClick.prototype.onClick = function(event) {
  'use strict';
  var permitted;

  // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.
  if (this.trackingClick) {
    this.targetElement = null;
    this.trackingClick = false;
    return true;
  }

  // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.
  if (event.target.type === 'submit' && event.detail === 0) {
    return true;
  }

  permitted = this.onMouse(event);

  // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.
  if (!permitted) {
    this.targetElement = null;
  }

  // If clicks are permitted, return true for the action to go through.
  return permitted;
};


/**
 * Remove all FastClick's event listeners.
 *
 * @returns {void}
 */
FastClick.prototype.destroy = function() {
  'use strict';
  var layer = this.layer;

  if (this.deviceIsAndroid) {
    layer.removeEventListener('mouseover', this.onMouse, true);
    layer.removeEventListener('mousedown', this.onMouse, true);
    layer.removeEventListener('mouseup', this.onMouse, true);
  }

  layer.removeEventListener('click', this.onClick, true);
  layer.removeEventListener('touchstart', this.onTouchStart, false);
  layer.removeEventListener('touchmove', this.onTouchMove, false);
  layer.removeEventListener('touchend', this.onTouchEnd, false);
  layer.removeEventListener('touchcancel', this.onTouchCancel, false);
};


/**
 * Check whether FastClick is needed.
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.notNeeded = function(layer) {
  'use strict';
  var metaViewport;
  var chromeVersion;

  // Devices that don't support touch don't need FastClick
  if (typeof window.ontouchstart === 'undefined') {
    return true;
  }

  // Chrome version - zero for other browsers
  chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [,0])[1];

  if (chromeVersion) {

    if (FastClick.prototype.deviceIsAndroid) {
      metaViewport = document.querySelector('meta[name=viewport]');

      if (metaViewport) {
        // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
        if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
          return true;
        }
        // Chrome 32 and above with width=device-width or less don't need FastClick
        if (chromeVersion > 31 && window.innerWidth <= window.screen.width) {
          return true;
        }
      }

    // Chrome desktop doesn't need FastClick (issue #15)
    } else {
      return true;
    }
  }

  // IE10 with -ms-touch-action: none, which disables double-tap-to-zoom (issue #97)
  if (layer.style.msTouchAction === 'none') {
    return true;
  }

  return false;
};


/**
 * Factory method for creating a FastClick object
 *
 * @param {Element} layer The layer to listen on
 */
FastClick.attach = function(layer) {
  'use strict';
  return new FastClick(layer);
};


if (typeof define !== 'undefined' && define.amd) {

  // AMD. Register as an anonymous module.
  define(function() {
    'use strict';
    return FastClick;
  });
} else if (typeof module !== 'undefined' && module.exports) {
  module.exports = FastClick.attach;
  module.exports.FastClick = FastClick;
} else {
  window.FastClick = FastClick;
}

/* **********************************************
     Begin jquery.debouncedresize.js
********************************************** */

/*
 * debouncedresize: special jQuery event that happens once after a window resize
 *
 * latest version and complete README available on Github:
 * https://github.com/louisremi/jquery-smartresize
 *
 * Copyright 2012 @louis_remi
 * Licensed under the MIT license.
 *
 * This saved you an hour of work? 
 * Send me music http://www.amazon.co.uk/wishlist/HNTU0468LQON
 */
(function($) {

var $event = $.event,
	$special,
	resizeTimeout;

$special = $event.special.debouncedresize = {
	setup: function() {
		$( this ).on( "resize", $special.handler );
	},
	teardown: function() {
		$( this ).off( "resize", $special.handler );
	},
	handler: function( event, execAsap ) {
		// Save the context
		var context = this,
			args = arguments,
			dispatch = function() {
				// set correct event type
				event.type = "debouncedresize";
				$event.dispatch.apply( context, args );
			};

		if ( resizeTimeout ) {
			clearTimeout( resizeTimeout );
		}

		execAsap ?
			dispatch() :
			resizeTimeout = setTimeout( dispatch, $special.threshold );
	},
	threshold: 150
};

})(jQuery);

/* **********************************************
     Begin jquery.imagesloaded.min.js
********************************************** */

(function(c,q){var m="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";c.fn.imagesLoaded=function(f){function n(){var b=c(j),a=c(h);d&&(h.length?d.reject(e,b,a):d.resolve(e));c.isFunction(f)&&f.call(g,e,b,a)}function p(b){k(b.target,"error"===b.type)}function k(b,a){b.src===m||-1!==c.inArray(b,l)||(l.push(b),a?h.push(b):j.push(b),c.data(b,"imagesLoaded",{isBroken:a,src:b.src}),r&&d.notifyWith(c(b),[a,e,c(j),c(h)]),e.length===l.length&&(setTimeout(n),e.unbind(".imagesLoaded",
p)))}var g=this,d=c.isFunction(c.Deferred)?c.Deferred():0,r=c.isFunction(d.notify),e=g.find("img").add(g.filter("img")),l=[],j=[],h=[];c.isPlainObject(f)&&c.each(f,function(b,a){if("callback"===b)f=a;else if(d)d[b](a)});e.length?e.bind("load.imagesLoaded error.imagesLoaded",p).each(function(b,a){var d=a.src,e=c.data(a,"imagesLoaded");if(e&&e.src===d)k(a,e.isBroken);else if(a.complete&&a.naturalWidth!==q)k(a,0===a.naturalWidth||0===a.naturalHeight);else if(a.readyState||a.complete)a.src=m,a.src=d}):
n();return d?d.promise(g):g}})(jQuery);


/* **********************************************
     Begin jquery.touchSwipe.js
********************************************** */

/*
* @fileOverview TouchSwipe - jQuery Plugin
* @version 1.6.5
*
* @author Matt Bryson http://www.github.com/mattbryson
* @see https://github.com/mattbryson/TouchSwipe-Jquery-Plugin
* @see http://labs.skinkers.com/touchSwipe/
* @see http://plugins.jquery.com/project/touchSwipe
*
* Copyright (c) 2010 Matt Bryson
* Dual licensed under the MIT or GPL Version 2 licenses.
*
*
* Changelog
* $Date: 2010-12-12 (Wed, 12 Dec 2010) $
* $version: 1.0.0
* $version: 1.0.1 - removed multibyte comments
*
* $Date: 2011-21-02 (Mon, 21 Feb 2011) $
* $version: 1.1.0   - added allowPageScroll property to allow swiping and scrolling of page
*         - changed handler signatures so one handler can be used for multiple events
* $Date: 2011-23-02 (Wed, 23 Feb 2011) $
* $version: 1.2.0   - added click handler. This is fired if the user simply clicks and does not swipe. The event object and click target are passed to handler.
*         - If you use the http://code.google.com/p/jquery-ui-for-ipad-and-iphone/ plugin, you can also assign jQuery mouse events to children of a touchSwipe object.
* $version: 1.2.1   - removed console log!
*
* $version: 1.2.2   - Fixed bug where scope was not preserved in callback methods.
*
* $Date: 2011-28-04 (Thurs, 28 April 2011) $
* $version: 1.2.4   - Changed licence terms to be MIT or GPL inline with jQuery. Added check for support of touch events to stop non compatible browsers erroring.
*
* $Date: 2011-27-09 (Tues, 27 September 2011) $
* $version: 1.2.5   - Added support for testing swipes with mouse on desktop browser (thanks to https://github.com/joelhy)
*
* $Date: 2012-14-05 (Mon, 14 May 2012) $
* $version: 1.2.6   - Added timeThreshold between start and end touch, so user can ignore slow swipes (thanks to Mark Chase). Default is null, all swipes are detected
*
* $Date: 2012-05-06 (Tues, 05 June 2012) $
* $version: 1.2.7   - Changed time threshold to have null default for backwards compatibility. Added duration param passed back in events, and refactored how time is handled.
*
* $Date: 2012-05-06 (Tues, 05 June 2012) $
* $version: 1.2.8   - Added the possibility to return a value like null or false in the trigger callback. In that way we can control when the touch start/move should take effect or not (simply by returning in some cases return null; or return false;) This effects the ontouchstart/ontouchmove event.
*
* $Date: 2012-06-06 (Wed, 06 June 2012) $
* $version: 1.3.0   - Refactored whole plugin to allow for methods to be executed, as well as exposed defaults for user override. Added 'enable', 'disable', and 'destroy' methods
*
* $Date: 2012-05-06 (Fri, 05 June 2012) $
* $version: 1.3.1   - Bug fixes  - bind() with false as last argument is no longer supported in jQuery 1.6, also, if you just click, the duration is now returned correctly.
*
* $Date: 2012-29-07 (Sun, 29 July 2012) $
* $version: 1.3.2 - Added fallbackToMouseEvents option to NOT capture mouse events on non touch devices.
*       - Added "all" fingers value to the fingers property, so any combination of fingers triggers the swipe, allowing event handlers to check the finger count
*
* $Date: 2012-09-08 (Thurs, 9 Aug 2012) $
* $version: 1.3.3 - Code tidy prep for minefied version
*
* $Date: 2012-04-10 (wed, 4 Oct 2012) $
* $version: 1.4.0 - Added pinch support, pinchIn and pinchOut
*
* $Date: 2012-11-10 (Thurs, 11 Oct 2012) $
* $version: 1.5.0 - Added excludedElements, a jquery selector that specifies child elements that do NOT trigger swipes. By default, this is one select that removes all form, input select, button and anchor elements.
*
* $Date: 2012-22-10 (Mon, 22 Oct 2012) $
* $version: 1.5.1 - Fixed bug with jQuery 1.8 and trailing comma in excludedElements
*         - Fixed bug with IE and eventPreventDefault()
* $Date: 2013-01-12 (Fri, 12 Jan 2013) $
* $version: 1.6.0 - Fixed bugs with pinching, mainly when both pinch and swipe enabled, as well as adding time threshold for multifinger gestures, so releasing one finger beofre the other doesnt trigger as single finger gesture.
*         - made the demo site all static local HTML pages so they can be run locally by a developer
*         - added jsDoc comments and added documentation for the plugin
*         - code tidy
*         - added triggerOnTouchLeave property that will end the event when the user swipes off the element.
* $Date: 2013-03-23 (Sat, 23 Mar 2013) $
* $version: 1.6.1 - Added support for ie8 touch events
* $version: 1.6.2 - Added support for events binding with on / off / bind in jQ for all callback names.
*                   - Deprecated the 'click' handler in favour of tap.
*                   - added cancelThreshold property
*                   - added option method to update init options at runtime
*
* $version 1.6.3    - added doubletap, longtap events and longTapThreshold, doubleTapThreshold property
* $Date: 2013-04-04 (Thurs, 04 April 2013) $
* $version 1.6.4    - Fixed bug with cancelThreshold introduced in 1.6.3, where swipe status no longer fired start event, and stopped once swiping back.
*
* $Date: 2013-08-24 (Sat, 24 Aug 2013) $
* $version 1.6.5    - Merged a few pull requests fixing various bugs, added AMD support.

*/

/**
 * See (http://jquery.com/).
 * @name $
 * @class
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 */

/**
 * See (http://jquery.com/)
 * @name fn
 * @class
 * See the jQuery Library  (http://jquery.com/) for full details.  This just
 * documents the function and classes that are added to jQuery by this plug-in.
 * @memberOf $
 */



(function (factory) {
    if (typeof define === 'function' && define.amd && define.amd.jQuery) {
        // AMD. Register as anonymous module.
        define(['jquery'], factory);
    } else {
        // Browser globals.
        factory(jQuery);
    }
}(function ($) {
  "use strict";

  //Constants
  var LEFT = "left",
    RIGHT = "right",
    UP = "up",
    DOWN = "down",
    IN = "in",
    OUT = "out",

    NONE = "none",
    AUTO = "auto",

    SWIPE = "swipe",
    PINCH = "pinch",
    TAP = "tap",
    DOUBLE_TAP = "doubletap",
    LONG_TAP = "longtap",

    HORIZONTAL = "horizontal",
    VERTICAL = "vertical",

    ALL_FINGERS = "all",

    DOUBLE_TAP_THRESHOLD = 10,

    PHASE_START = "start",
    PHASE_MOVE = "move",
    PHASE_END = "end",
    PHASE_CANCEL = "cancel",

    SUPPORTS_TOUCH = 'ontouchstart' in window,

    PLUGIN_NS = 'TouchSwipe';



  /**
  * The default configuration, and available options to configure touch swipe with.
  * You can set the default values by updating any of the properties prior to instantiation.
  * @name $.fn.swipe.defaults
  * @namespace
  * @property {int} [fingers=1] The number of fingers to detect in a swipe. Any swipes that do not meet this requirement will NOT trigger swipe handlers.
  * @property {int} [threshold=75] The number of pixels that the user must move their finger by before it is considered a swipe.
  * @property {int} [cancelThreshold=null] The number of pixels that the user must move their finger back from the original swipe direction to cancel the gesture.
  * @property {int} [pinchThreshold=20] The number of pixels that the user must pinch their finger by before it is considered a pinch.
  * @property {int} [maxTimeThreshold=null] Time, in milliseconds, between touchStart and touchEnd must NOT exceed in order to be considered a swipe.
  * @property {int} [fingerReleaseThreshold=250] Time in milliseconds between releasing multiple fingers.  If 2 fingers are down, and are released one after the other, if they are within this threshold, it counts as a simultaneous release.
  * @property {int} [longTapThreshold=500] Time in milliseconds between tap and release for a long tap
    * @property {int} [doubleTapThreshold=200] Time in milliseconds between 2 taps to count as a double tap
  * @property {function} [swipe=null] A handler to catch all swipes. See {@link $.fn.swipe#event:swipe}
  * @property {function} [swipeLeft=null] A handler that is triggered for "left" swipes. See {@link $.fn.swipe#event:swipeLeft}
  * @property {function} [swipeRight=null] A handler that is triggered for "right" swipes. See {@link $.fn.swipe#event:swipeRight}
  * @property {function} [swipeUp=null] A handler that is triggered for "up" swipes. See {@link $.fn.swipe#event:swipeUp}
  * @property {function} [swipeDown=null] A handler that is triggered for "down" swipes. See {@link $.fn.swipe#event:swipeDown}
  * @property {function} [swipeStatus=null] A handler triggered for every phase of the swipe. See {@link $.fn.swipe#event:swipeStatus}
  * @property {function} [pinchIn=null] A handler triggered for pinch in events. See {@link $.fn.swipe#event:pinchIn}
  * @property {function} [pinchOut=null] A handler triggered for pinch out events. See {@link $.fn.swipe#event:pinchOut}
  * @property {function} [pinchStatus=null] A handler triggered for every phase of a pinch. See {@link $.fn.swipe#event:pinchStatus}
  * @property {function} [tap=null] A handler triggered when a user just taps on the item, rather than swipes it. If they do not move, tap is triggered, if they do move, it is not.
  * @property {function} [doubleTap=null] A handler triggered when a user double taps on the item. The delay between taps can be set with the doubleTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
  * @property {function} [longTap=null] A handler triggered when a user long taps on the item. The delay between start and end can be set with the longTapThreshold property. See {@link $.fn.swipe.defaults#doubleTapThreshold}
  * @property {boolean} [triggerOnTouchEnd=true] If true, the swipe events are triggered when the touch end event is received (user releases finger).  If false, it will be triggered on reaching the threshold, and then cancel the touch event automatically.
  * @property {boolean} [triggerOnTouchLeave=false] If true, then when the user leaves the swipe object, the swipe will end and trigger appropriate handlers.
  * @property {string|undefined} [allowPageScroll='auto'] How the browser handles page scrolls when the user is swiping on a touchSwipe object. See {@link $.fn.swipe.pageScroll}.  <br/><br/>
                    <code>"auto"</code> : all undefined swipes will cause the page to scroll in that direction. <br/>
                    <code>"none"</code> : the page will not scroll when user swipes. <br/>
                    <code>"horizontal"</code> : will force page to scroll on horizontal swipes. <br/>
                    <code>"vertical"</code> : will force page to scroll on vertical swipes. <br/>
  * @property {boolean} [fallbackToMouseEvents=true] If true mouse events are used when run on a non touch device, false will stop swipes being triggered by mouse events on non tocuh devices.
  * @property {string} [excludedElements="button, input, select, textarea, a, .noSwipe"] A jquery selector that specifies child elements that do NOT trigger swipes. By default this excludes all form, input, select, button, anchor and .noSwipe elements.

  */
  var defaults = {
    fingers: 1,
    threshold: 75,
    cancelThreshold:null,
    pinchThreshold:20,
    maxTimeThreshold: null,
    fingerReleaseThreshold:250,
    longTapThreshold:500,
    doubleTapThreshold:200,
    swipe: null,
    swipeLeft: null,
    swipeRight: null,
    swipeUp: null,
    swipeDown: null,
    swipeStatus: null,
    pinchIn:null,
    pinchOut:null,
    pinchStatus:null,
    click:null, //Deprecated since 1.6.2
    tap:null,
    doubleTap:null,
    longTap:null,
    triggerOnTouchEnd: true,
    triggerOnTouchLeave:false,
    allowPageScroll: "auto",
    fallbackToMouseEvents: true,
    excludedElements:"label, button, input, select, textarea, a, .noSwipe"
  };



  /**
  * Applies TouchSwipe behaviour to one or more jQuery objects.
  * The TouchSwipe plugin can be instantiated via this method, or methods within
  * TouchSwipe can be executed via this method as per jQuery plugin architecture.
  * @see TouchSwipe
  * @class
  * @param {Mixed} method If the current DOMNode is a TouchSwipe object, and <code>method</code> is a TouchSwipe method, then
  * the <code>method</code> is executed, and any following arguments are passed to the TouchSwipe method.
  * If <code>method</code> is an object, then the TouchSwipe class is instantiated on the current DOMNode, passing the
  * configuration properties defined in the object. See TouchSwipe
  *
  */
  $.fn.swipe = function (method) {
    var $this = $(this),
      plugin = $this.data(PLUGIN_NS);

    //Check if we are already instantiated and trying to execute a method
    if (plugin && typeof method === 'string') {
      if (plugin[method]) {
        return plugin[method].apply(this, Array.prototype.slice.call(arguments, 1));
      } else {
        $.error('Method ' + method + ' does not exist on jQuery.swipe');
      }
    }
    //Else not instantiated and trying to pass init object (or nothing)
    else if (!plugin && (typeof method === 'object' || !method)) {
      return init.apply(this, arguments);
    }

    return $this;
  };

  //Expose our defaults so a user could override the plugin defaults
  $.fn.swipe.defaults = defaults;

  /**
  * The phases that a touch event goes through.  The <code>phase</code> is passed to the event handlers.
  * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
  * @namespace
  * @readonly
  * @property {string} PHASE_START Constant indicating the start phase of the touch event. Value is <code>"start"</code>.
  * @property {string} PHASE_MOVE Constant indicating the move phase of the touch event. Value is <code>"move"</code>.
  * @property {string} PHASE_END Constant indicating the end phase of the touch event. Value is <code>"end"</code>.
  * @property {string} PHASE_CANCEL Constant indicating the cancel phase of the touch event. Value is <code>"cancel"</code>.
  */
  $.fn.swipe.phases = {
    PHASE_START: PHASE_START,
    PHASE_MOVE: PHASE_MOVE,
    PHASE_END: PHASE_END,
    PHASE_CANCEL: PHASE_CANCEL
  };

  /**
  * The direction constants that are passed to the event handlers.
  * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
  * @namespace
  * @readonly
  * @property {string} LEFT Constant indicating the left direction. Value is <code>"left"</code>.
  * @property {string} RIGHT Constant indicating the right direction. Value is <code>"right"</code>.
  * @property {string} UP Constant indicating the up direction. Value is <code>"up"</code>.
  * @property {string} DOWN Constant indicating the down direction. Value is <code>"cancel"</code>.
  * @property {string} IN Constant indicating the in direction. Value is <code>"in"</code>.
  * @property {string} OUT Constant indicating the out direction. Value is <code>"out"</code>.
  */
  $.fn.swipe.directions = {
    LEFT: LEFT,
    RIGHT: RIGHT,
    UP: UP,
    DOWN: DOWN,
    IN : IN,
    OUT: OUT
  };

  /**
  * The page scroll constants that can be used to set the value of <code>allowPageScroll</code> option
  * These properties are read only
  * @namespace
  * @readonly
  * @see $.fn.swipe.defaults#allowPageScroll
  * @property {string} NONE Constant indicating no page scrolling is allowed. Value is <code>"none"</code>.
  * @property {string} HORIZONTAL Constant indicating horizontal page scrolling is allowed. Value is <code>"horizontal"</code>.
  * @property {string} VERTICAL Constant indicating vertical page scrolling is allowed. Value is <code>"vertical"</code>.
  * @property {string} AUTO Constant indicating either horizontal or vertical will be allowed, depending on the swipe handlers registered. Value is <code>"auto"</code>.
  */
  $.fn.swipe.pageScroll = {
    NONE: NONE,
    HORIZONTAL: HORIZONTAL,
    VERTICAL: VERTICAL,
    AUTO: AUTO
  };

  /**
  * Constants representing the number of fingers used in a swipe.  These are used to set both the value of <code>fingers</code> in the
  * options object, as well as the value of the <code>fingers</code> event property.
  * These properties are read only, attempting to change them will not alter the values passed to the event handlers.
  * @namespace
  * @readonly
  * @see $.fn.swipe.defaults#fingers
  * @property {string} ONE Constant indicating 1 finger is to be detected / was detected. Value is <code>1</code>.
  * @property {string} TWO Constant indicating 2 fingers are to be detected / were detected. Value is <code>1</code>.
  * @property {string} THREE Constant indicating 3 finger are to be detected / were detected. Value is <code>1</code>.
  * @property {string} ALL Constant indicating any combination of finger are to be detected.  Value is <code>"all"</code>.
  */
  $.fn.swipe.fingers = {
    ONE: 1,
    TWO: 2,
    THREE: 3,
    ALL: ALL_FINGERS
  };

  /**
  * Initialise the plugin for each DOM element matched
  * This creates a new instance of the main TouchSwipe class for each DOM element, and then
  * saves a reference to that instance in the elements data property.
  * @internal
  */
  function init(options) {
    //Prep and extend the options
    if (options && (options.allowPageScroll === undefined && (options.swipe !== undefined || options.swipeStatus !== undefined))) {
      options.allowPageScroll = NONE;
    }

        //Check for deprecated options
    //Ensure that any old click handlers are assigned to the new tap, unless we have a tap
    if(options.click!==undefined && options.tap===undefined) {
        options.tap = options.click;
    }

    if (!options) {
      options = {};
    }

        //pass empty object so we dont modify the defaults
    options = $.extend({}, $.fn.swipe.defaults, options);

    //For each element instantiate the plugin
    return this.each(function () {
      var $this = $(this);

      //Check we havent already initialised the plugin
      var plugin = $this.data(PLUGIN_NS);

      if (!plugin) {
        plugin = new TouchSwipe(this, options);
        $this.data(PLUGIN_NS, plugin);
      }
    });
  }

  /**
  * Main TouchSwipe Plugin Class.
  * Do not use this to construct your TouchSwipe object, use the jQuery plugin method $.fn.swipe(); {@link $.fn.swipe}
  * @private
  * @name TouchSwipe
  * @param {DOMNode} element The HTML DOM object to apply to plugin to
  * @param {Object} options The options to configure the plugin with.  @link {$.fn.swipe.defaults}
  * @see $.fh.swipe.defaults
  * @see $.fh.swipe
    * @class
  */
  function TouchSwipe(element, options) {
    var useTouchEvents = (SUPPORTS_TOUCH || !options.fallbackToMouseEvents),
      START_EV = useTouchEvents ? 'touchstart' : 'mousedown',
      MOVE_EV = useTouchEvents ? 'touchmove' : 'mousemove',
      END_EV = useTouchEvents ? 'touchend' : 'mouseup',
      LEAVE_EV = useTouchEvents ? null : 'mouseleave', //we manually detect leave on touch devices, so null event here
      CANCEL_EV = 'touchcancel';



    //touch properties
    var distance = 0,
      direction = null,
      duration = 0,
      startTouchesDistance = 0,
      endTouchesDistance = 0,
      pinchZoom = 1,
      pinchDistance = 0,
      pinchDirection = 0,
      maximumsMap=null;



    //jQuery wrapped element for this instance
    var $element = $(element);

    //Current phase of th touch cycle
    var phase = "start";

    // the current number of fingers being used.
    var fingerCount = 0;

    //track mouse points / delta
    var fingerData=null;

    //track times
    var startTime = 0,
      endTime = 0,
      previousTouchEndTime=0,
      previousTouchFingerCount=0,
      doubleTapStartTime=0;

        //Timeouts
        var singleTapTimeout=null;

    // Add gestures to all swipable areas if supported
    try {
      $element.bind(START_EV, touchStart);
      $element.bind(CANCEL_EV, touchCancel);
    }
    catch (e) {
      $.error('events not supported ' + START_EV + ',' + CANCEL_EV + ' on jQuery.swipe');
    }

    //
    //Public methods
    //

    /**
    * re-enables the swipe plugin with the previous configuration
    * @function
    * @name $.fn.swipe#enable
    * @return {DOMNode} The Dom element that was registered with TouchSwipe
    * @example $("#element").swipe("enable");
    */
    this.enable = function () {
      $element.bind(START_EV, touchStart);
      $element.bind(CANCEL_EV, touchCancel);
      return $element;
    };

    /**
    * disables the swipe plugin
    * @function
    * @name $.fn.swipe#disable
    * @return {DOMNode} The Dom element that is now registered with TouchSwipe
      * @example $("#element").swipe("disable");
    */
    this.disable = function () {
      removeListeners();
      return $element;
    };

    /**
    * Destroy the swipe plugin completely. To use any swipe methods, you must re initialise the plugin.
    * @function
    * @name $.fn.swipe#destroy
    * @return {DOMNode} The Dom element that was registered with TouchSwipe
    * @example $("#element").swipe("destroy");
    */
    this.destroy = function () {
      removeListeners();
      $element.data(PLUGIN_NS, null);
      return $element;
    };


        /**
         * Allows run time updating of the swipe configuration options.
         * @function
       * @name $.fn.swipe#option
       * @param {String} property The option property to get or set
         * @param {Object} [value] The value to set the property to
     * @return {Object} If only a property name is passed, then that property value is returned.
     * @example $("#element").swipe("option", "threshold"); // return the threshold
         * @example $("#element").swipe("option", "threshold", 100); // set the threshold after init
         * @see $.fn.swipe.defaults
         *
         */
        this.option = function (property, value) {
            if(options[property]!==undefined) {
                if(value===undefined) {
                    return options[property];
                } else {
                    options[property] = value;
                }
            } else {
                $.error('Option ' + property + ' does not exist on jQuery.swipe.options');
            }

            return null;
        }

    //
    // Private methods
    //

    //
    // EVENTS
    //
    /**
    * Event handler for a touch start event.
    * Stops the default click event from triggering and stores where we touched
    * @inner
    * @param {object} jqEvent The normalised jQuery event object.
    */
    function touchStart(jqEvent) {
      //If we already in a touch event (a finger already in use) then ignore subsequent ones..
      if( getTouchInProgress() )
        return;

      //Check if this element matches any in the excluded elements selectors,  or its parent is excluded, if so, DON'T swipe
      if( $(jqEvent.target).closest( options.excludedElements, $element ).length>0 )
        return;

      //As we use Jquery bind for events, we need to target the original event object
      //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
      var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;

      var ret,
        evt = SUPPORTS_TOUCH ? event.touches[0] : event;

      phase = PHASE_START;

      //If we support touches, get the finger count
      if (SUPPORTS_TOUCH) {
        // get the total number of fingers touching the screen
        fingerCount = event.touches.length;
      }
      //Else this is the desktop, so stop the browser from dragging the image
      else {
        jqEvent.preventDefault(); //call this on jq event so we are cross browser
      }

      //clear vars..
      distance = 0;
      direction = null;
      pinchDirection=null;
      duration = 0;
      startTouchesDistance=0;
      endTouchesDistance=0;
      pinchZoom = 1;
      pinchDistance = 0;
      fingerData=createAllFingerData();
      maximumsMap=createMaximumsData();
      cancelMultiFingerRelease();


      // check the number of fingers is what we are looking for, or we are capturing pinches
      if (!SUPPORTS_TOUCH || (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || hasPinches()) {
        // get the coordinates of the touch
        createFingerData( 0, evt );
        startTime = getTimeStamp();

        if(fingerCount==2) {
          //Keep track of the initial pinch distance, so we can calculate the diff later
          //Store second finger data as start
          createFingerData( 1, event.touches[1] );
          startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
        }

        if (options.swipeStatus || options.pinchStatus) {
          ret = triggerHandler(event, phase);
        }
      }
      else {
        //A touch with more or less than the fingers we are looking for, so cancel
        ret = false;
      }

      //If we have a return value from the users handler, then return and cancel
      if (ret === false) {
        phase = PHASE_CANCEL;
        triggerHandler(event, phase);
        return ret;
      }
      else {
        setTouchInProgress(true);
      }

            return null;
    };



    /**
    * Event handler for a touch move event.
    * If we change fingers during move, then cancel the event
    * @inner
    * @param {object} jqEvent The normalised jQuery event object.
    */
    function touchMove(jqEvent) {

      //As we use Jquery bind for events, we need to target the original event object
      //If these events are being programmatically triggered, we don't have an original event object, so use the Jq one.
      var event = jqEvent.originalEvent ? jqEvent.originalEvent : jqEvent;

      //If we are ending, cancelling, or within the threshold of 2 fingers being released, don't track anything..
      if (phase === PHASE_END || phase === PHASE_CANCEL || inMultiFingerRelease())
        return;

      var ret,
        evt = SUPPORTS_TOUCH ? event.touches[0] : event;


      //Update the  finger data
      var currentFinger = updateFingerData(evt);
      endTime = getTimeStamp();

      if (SUPPORTS_TOUCH) {
        fingerCount = event.touches.length;
      }

      phase = PHASE_MOVE;

      //If we have 2 fingers get Touches distance as well
      if(fingerCount==2) {

        //Keep track of the initial pinch distance, so we can calculate the diff later
        //We do this here as well as the start event, in case they start with 1 finger, and the press 2 fingers
        if(startTouchesDistance==0) {
          //Create second finger if this is the first time...
          createFingerData( 1, event.touches[1] );

          startTouchesDistance = endTouchesDistance = calculateTouchesDistance(fingerData[0].start, fingerData[1].start);
        } else {
          //Else just update the second finger
          updateFingerData(event.touches[1]);

          endTouchesDistance = calculateTouchesDistance(fingerData[0].end, fingerData[1].end);
          pinchDirection = calculatePinchDirection(fingerData[0].end, fingerData[1].end);
        }


        pinchZoom = calculatePinchZoom(startTouchesDistance, endTouchesDistance);
        pinchDistance = Math.abs(startTouchesDistance - endTouchesDistance);
      }


      if ( (fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH || hasPinches() ) {

        direction = calculateDirection(currentFinger.start, currentFinger.end);

        //Check if we need to prevent default event (page scroll / pinch zoom) or not
        validateDefaultEvent(jqEvent, direction);

        //Distance and duration are all off the main finger
        distance = calculateDistance(currentFinger.start, currentFinger.end);
        duration = calculateDuration();

                //Cache the maximum distance we made in this direction
                setMaxDistance(direction, distance);


        if (options.swipeStatus || options.pinchStatus) {
          ret = triggerHandler(event, phase);
        }


        //If we trigger end events when threshold are met, or trigger events when touch leaves element
        if(!options.triggerOnTouchEnd || options.triggerOnTouchLeave) {

          var inBounds = true;

          //If checking if we leave the element, run the bounds check (we can use touchleave as its not supported on webkit)
          if(options.triggerOnTouchLeave) {
            var bounds = getbounds( this );
            inBounds = isInBounds( currentFinger.end, bounds );
          }

          //Trigger end handles as we swipe if thresholds met or if we have left the element if the user has asked to check these..
          if(!options.triggerOnTouchEnd && inBounds) {
            phase = getNextPhase( PHASE_MOVE );
          }
          //We end if out of bounds here, so set current phase to END, and check if its modified
          else if(options.triggerOnTouchLeave && !inBounds ) {
            phase = getNextPhase( PHASE_END );
          }

          if(phase==PHASE_CANCEL || phase==PHASE_END) {
            triggerHandler(event, phase);
          }
        }
      }
      else {
        phase = PHASE_CANCEL;
        triggerHandler(event, phase);
      }

      if (ret === false) {
        phase = PHASE_CANCEL;
        triggerHandler(event, phase);
      }
    }



    /**
    * Event handler for a touch end event.
    * Calculate the direction and trigger events
    * @inner
    * @param {object} jqEvent The normalised jQuery event object.
    */
    function touchEnd(jqEvent) {
      //As we use Jquery bind for events, we need to target the original event object
      var event = jqEvent.originalEvent;


      //If we are still in a touch with another finger return
      //This allows us to wait a fraction and see if the other finger comes up, if it does within the threshold, then we treat it as a multi release, not a single release.
      if (SUPPORTS_TOUCH) {
        if(event.touches.length>0) {
          startMultiFingerRelease();
          return true;
        }
      }

      //If a previous finger has been released, check how long ago, if within the threshold, then assume it was a multifinger release.
      //This is used to allow 2 fingers to release fractionally after each other, whilst maintainig the event as containg 2 fingers, not 1
      if(inMultiFingerRelease()) {
        fingerCount=previousTouchFingerCount;
      }

      //call this on jq event so we are cross browser
      jqEvent.preventDefault();

      //Set end of swipe
      endTime = getTimeStamp();

      //Get duration incase move was never fired
      duration = calculateDuration();

      //If we trigger handlers at end of swipe OR, we trigger during, but they didnt trigger and we are still in the move phase
      if(didSwipeBackToCancel()) {
          phase = PHASE_CANCEL;
                triggerHandler(event, phase);
      } else if (options.triggerOnTouchEnd || (options.triggerOnTouchEnd == false && phase === PHASE_MOVE)) {
        phase = PHASE_END;
                triggerHandler(event, phase);
      }
      //Special cases - A tap should always fire on touch end regardless,
      //So here we manually trigger the tap end handler by itself
      //We dont run trigger handler as it will re-trigger events that may have fired already
      else if (!options.triggerOnTouchEnd && hasTap()) {
                //Trigger the pinch events...
          phase = PHASE_END;
          triggerHandlerForGesture(event, phase, TAP);
      }
      else if (phase === PHASE_MOVE) {
        phase = PHASE_CANCEL;
        triggerHandler(event, phase);
      }

      setTouchInProgress(false);

            return null;
    }



    /**
    * Event handler for a touch cancel event.
    * Clears current vars
    * @inner
    */
    function touchCancel() {
      // reset the variables back to default values
      fingerCount = 0;
      endTime = 0;
      startTime = 0;
      startTouchesDistance=0;
      endTouchesDistance=0;
      pinchZoom=1;

      //If we were in progress of tracking a possible multi touch end, then re set it.
      cancelMultiFingerRelease();

      setTouchInProgress(false);
    }


    /**
    * Event handler for a touch leave event.
    * This is only triggered on desktops, in touch we work this out manually
    * as the touchleave event is not supported in webkit
    * @inner
    */
    function touchLeave(jqEvent) {
      var event = jqEvent.originalEvent;

      //If we have the trigger on leave property set....
      if(options.triggerOnTouchLeave) {
        phase = getNextPhase( PHASE_END );
        triggerHandler(event, phase);
      }
    }

    /**
    * Removes all listeners that were associated with the plugin
    * @inner
    */
    function removeListeners() {
      $element.unbind(START_EV, touchStart);
      $element.unbind(CANCEL_EV, touchCancel);
      $element.unbind(MOVE_EV, touchMove);
      $element.unbind(END_EV, touchEnd);

      //we only have leave events on desktop, we manually calculate leave on touch as its not supported in webkit
      if(LEAVE_EV) {
        $element.unbind(LEAVE_EV, touchLeave);
      }

      setTouchInProgress(false);
    }


    /**
     * Checks if the time and distance thresholds have been met, and if so then the appropriate handlers are fired.
     */
    function getNextPhase(currentPhase) {

      var nextPhase = currentPhase;

      // Ensure we have valid swipe (under time and over distance  and check if we are out of bound...)
      var validTime = validateSwipeTime();
      var validDistance = validateSwipeDistance();
      var didCancel = didSwipeBackToCancel();

      //If we have exceeded our time, then cancel
      if(!validTime || didCancel) {
        nextPhase = PHASE_CANCEL;
      }
      //Else if we are moving, and have reached distance then end
      else if (validDistance && currentPhase == PHASE_MOVE && (!options.triggerOnTouchEnd || options.triggerOnTouchLeave) ) {
        nextPhase = PHASE_END;
      }
      //Else if we have ended by leaving and didn't reach distance, then cancel
      else if (!validDistance && currentPhase==PHASE_END && options.triggerOnTouchLeave) {
        nextPhase = PHASE_CANCEL;
      }

      return nextPhase;
    }


    /**
    * Trigger the relevant event handler
    * The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
    * @param {object} event the original event object
    * @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
    * @inner
    */
    function triggerHandler(event, phase) {

      var ret = undefined;

      // SWIPE GESTURES
      if(didSwipe() || hasSwipes()) { //hasSwipes as status needs to fire even if swipe is invalid
        //Trigger the swipe events...
        ret = triggerHandlerForGesture(event, phase, SWIPE);
      }

      // PINCH GESTURES (if the above didn't cancel)
      else if((didPinch() || hasPinches()) && ret!==false) {
        //Trigger the pinch events...
        ret = triggerHandlerForGesture(event, phase, PINCH);
      }

      // CLICK / TAP (if the above didn't cancel)
      if(didDoubleTap() && ret!==false) {
        //Trigger the tap events...
        ret = triggerHandlerForGesture(event, phase, DOUBLE_TAP);
      }

      // CLICK / TAP (if the above didn't cancel)
      else if(didLongTap() && ret!==false) {
        //Trigger the tap events...
        ret = triggerHandlerForGesture(event, phase, LONG_TAP);
      }

      // CLICK / TAP (if the above didn't cancel)
      else if(didTap() && ret!==false) {
        //Trigger the tap event..
        ret = triggerHandlerForGesture(event, phase, TAP);
        }



      // If we are cancelling the gesture, then manually trigger the reset handler
      if (phase === PHASE_CANCEL) {
        touchCancel(event);
      }

      // If we are ending the gesture, then manually trigger the reset handler IF all fingers are off
      if(phase === PHASE_END) {
        //If we support touch, then check that all fingers are off before we cancel
        if (SUPPORTS_TOUCH) {
          if(event.touches.length==0) {
            touchCancel(event);
          }
        }
        else {
          touchCancel(event);
        }
      }

      return ret;
    }



    /**
    * Trigger the relevant event handler
    * The handlers are passed the original event, the element that was swiped, and in the case of the catch all handler, the direction that was swiped, "left", "right", "up", or "down"
    * @param {object} event the original event object
    * @param {string} phase the phase of the swipe (start, end cancel etc) {@link $.fn.swipe.phases}
    * @param {string} gesture the gesture to trigger a handler for : PINCH or SWIPE {@link $.fn.swipe.gestures}
    * @return Boolean False, to indicate that the event should stop propagation, or void.
    * @inner
    */
    function triggerHandlerForGesture(event, phase, gesture) {

      var ret=undefined;

      //SWIPES....
      if(gesture==SWIPE) {
        //Trigger status every time..

        //Trigger the event...
        $element.trigger('swipeStatus', [phase, direction || null, distance || 0, duration || 0, fingerCount]);

        //Fire the callback
        if (options.swipeStatus) {
          ret = options.swipeStatus.call($element, event, phase, direction || null, distance || 0, duration || 0, fingerCount);
          //If the status cancels, then dont run the subsequent event handlers..
          if(ret===false) return false;
        }




        if (phase == PHASE_END && validateSwipe()) {
          //Fire the catch all event
          $element.trigger('swipe', [direction, distance, duration, fingerCount]);

          //Fire catch all callback
          if (options.swipe) {
            ret = options.swipe.call($element, event, direction, distance, duration, fingerCount);
            //If the status cancels, then dont run the subsequent event handlers..
            if(ret===false) return false;
          }

          //trigger direction specific event handlers
          switch (direction) {
            case LEFT:
              //Trigger the event
              $element.trigger('swipeLeft', [direction, distance, duration, fingerCount]);

                  //Fire the callback
              if (options.swipeLeft) {
                ret = options.swipeLeft.call($element, event, direction, distance, duration, fingerCount);
              }
              break;

            case RIGHT:
              //Trigger the event
                  $element.trigger('swipeRight', [direction, distance, duration, fingerCount]);

                  //Fire the callback
              if (options.swipeRight) {
                ret = options.swipeRight.call($element, event, direction, distance, duration, fingerCount);
              }
              break;

            case UP:
              //Trigger the event
                  $element.trigger('swipeUp', [direction, distance, duration, fingerCount]);

                  //Fire the callback
              if (options.swipeUp) {
                ret = options.swipeUp.call($element, event, direction, distance, duration, fingerCount);
              }
              break;

            case DOWN:
              //Trigger the event
                  $element.trigger('swipeDown', [direction, distance, duration, fingerCount]);

                  //Fire the callback
              if (options.swipeDown) {
                ret = options.swipeDown.call($element, event, direction, distance, duration, fingerCount);
              }
              break;
          }
        }
      }


      //PINCHES....
      if(gesture==PINCH) {
        //Trigger the event
           $element.trigger('pinchStatus', [phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);

                //Fire the callback
        if (options.pinchStatus) {
          ret = options.pinchStatus.call($element, event, phase, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
          //If the status cancels, then dont run the subsequent event handlers..
          if(ret===false) return false;
        }

        if(phase==PHASE_END && validatePinch()) {

          switch (pinchDirection) {
            case IN:
              //Trigger the event
                            $element.trigger('pinchIn', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);

                            //Fire the callback
                            if (options.pinchIn) {
                ret = options.pinchIn.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
              }
              break;

            case OUT:
              //Trigger the event
                            $element.trigger('pinchOut', [pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom]);

                            //Fire the callback
                            if (options.pinchOut) {
                ret = options.pinchOut.call($element, event, pinchDirection || null, pinchDistance || 0, duration || 0, fingerCount, pinchZoom);
              }
              break;
          }
        }
      }





      if(gesture==TAP) {
        if(phase === PHASE_CANCEL || phase === PHASE_END) {


              //Cancel any existing double tap
            clearTimeout(singleTapTimeout);

          //If we are also looking for doubelTaps, wait incase this is one...
            if(hasDoubleTap() && !inDoubleTap()) {
                //Cache the time of this tap
                        doubleTapStartTime = getTimeStamp();

                //Now wait for the double tap timeout, and trigger this single tap
                //if its not cancelled by a double tap
                singleTapTimeout = setTimeout($.proxy(function() {
                      doubleTapStartTime=null;
                      //Trigger the event
                            $element.trigger('tap', [event.target]);


                            //Fire the callback
                            if(options.tap) {
                                ret = options.tap.call($element, event, event.target);
                            }
                  }, this), options.doubleTapThreshold );

              } else {
                        doubleTapStartTime=null;

                        //Trigger the event
                        $element.trigger('tap', [event.target]);


                        //Fire the callback
                        if(options.tap) {
                            ret = options.tap.call($element, event, event.target);
                        }
              }
          }
      }

      else if (gesture==DOUBLE_TAP) {
        if(phase === PHASE_CANCEL || phase === PHASE_END) {
          //Cancel any pending singletap
            clearTimeout(singleTapTimeout);
            doubleTapStartTime=null;

                    //Trigger the event
                    $element.trigger('doubletap', [event.target]);

                    //Fire the callback
                    if(options.doubleTap) {
                        ret = options.doubleTap.call($element, event, event.target);
                    }
          }
      }

      else if (gesture==LONG_TAP) {
        if(phase === PHASE_CANCEL || phase === PHASE_END) {
          //Cancel any pending singletap (shouldnt be one)
            clearTimeout(singleTapTimeout);
            doubleTapStartTime=null;

                    //Trigger the event
                    $element.trigger('longtap', [event.target]);

                    //Fire the callback
                    if(options.longTap) {
                        ret = options.longTap.call($element, event, event.target);
                    }
          }
      }

      return ret;
    }




    //
    // GESTURE VALIDATION
    //

    /**
    * Checks the user has swipe far enough
    * @return Boolean if <code>threshold</code> has been set, return true if the threshold was met, else false.
    * If no threshold was set, then we return true.
    * @inner
    */
    function validateSwipeDistance() {
      var valid = true;
      //If we made it past the min swipe distance..
      if (options.threshold !== null) {
        valid = distance >= options.threshold;
      }

            return valid;
    }

    /**
    * Checks the user has swiped back to cancel.
    * @return Boolean if <code>cancelThreshold</code> has been set, return true if the cancelThreshold was met, else false.
    * If no cancelThreshold was set, then we return true.
    * @inner
    */
    function didSwipeBackToCancel() {
            var cancelled = false;
        if(options.cancelThreshold !== null && direction !==null)  {
            cancelled =  (getMaxDistance( direction ) - distance) >= options.cancelThreshold;
      }

      return cancelled;
    }

    /**
    * Checks the user has pinched far enough
    * @return Boolean if <code>pinchThreshold</code> has been set, return true if the threshold was met, else false.
    * If no threshold was set, then we return true.
    * @inner
    */
    function validatePinchDistance() {
      if (options.pinchThreshold !== null) {
        return pinchDistance >= options.pinchThreshold;
      }
      return true;
    }

    /**
    * Checks that the time taken to swipe meets the minimum / maximum requirements
    * @return Boolean
    * @inner
    */
    function validateSwipeTime() {
      var result;
      //If no time set, then return true

      if (options.maxTimeThreshold) {
        if (duration >= options.maxTimeThreshold) {
          result = false;
        } else {
          result = true;
        }
      }
      else {
        result = true;
      }

      return result;
    }


    /**
    * Checks direction of the swipe and the value allowPageScroll to see if we should allow or prevent the default behaviour from occurring.
    * This will essentially allow page scrolling or not when the user is swiping on a touchSwipe object.
    * @param {object} jqEvent The normalised jQuery representation of the event object.
    * @param {string} direction The direction of the event. See {@link $.fn.swipe.directions}
    * @see $.fn.swipe.directions
    * @inner
    */
    function validateDefaultEvent(jqEvent, direction) {
      if (options.allowPageScroll === NONE || hasPinches()) {
        jqEvent.preventDefault();
      } else {
        var auto = options.allowPageScroll === AUTO;

        switch (direction) {
          case LEFT:
            if ((options.swipeLeft && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
              jqEvent.preventDefault();
            }
            break;

          case RIGHT:
            if ((options.swipeRight && auto) || (!auto && options.allowPageScroll != HORIZONTAL)) {
              jqEvent.preventDefault();
            }
            break;

          case UP:
            if ((options.swipeUp && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
              jqEvent.preventDefault();
            }
            break;

          case DOWN:
            if ((options.swipeDown && auto) || (!auto && options.allowPageScroll != VERTICAL)) {
              jqEvent.preventDefault();
            }
            break;
        }
      }

    }


    // PINCHES
    /**
     * Returns true of the current pinch meets the thresholds
     * @return Boolean
     * @inner
    */
    function validatePinch() {
        var hasCorrectFingerCount = validateFingers();
        var hasEndPoint = validateEndPoint();
      var hasCorrectDistance = validatePinchDistance();
      return hasCorrectFingerCount && hasEndPoint && hasCorrectDistance;

    }

    /**
     * Returns true if any Pinch events have been registered
     * @return Boolean
     * @inner
    */
    function hasPinches() {
      //Enure we dont return 0 or null for false values
      return !!(options.pinchStatus || options.pinchIn || options.pinchOut);
    }

    /**
     * Returns true if we are detecting pinches, and have one
     * @return Boolean
     * @inner
     */
    function didPinch() {
      //Enure we dont return 0 or null for false values
      return !!(validatePinch() && hasPinches());
    }




    // SWIPES
    /**
     * Returns true if the current swipe meets the thresholds
     * @return Boolean
     * @inner
    */
    function validateSwipe() {
      //Check validity of swipe
      var hasValidTime = validateSwipeTime();
      var hasValidDistance = validateSwipeDistance();
      var hasCorrectFingerCount = validateFingers();
        var hasEndPoint = validateEndPoint();
        var didCancel = didSwipeBackToCancel();

      // if the user swiped more than the minimum length, perform the appropriate action
      // hasValidDistance is null when no distance is set
      var valid =  !didCancel && hasEndPoint && hasCorrectFingerCount && hasValidDistance && hasValidTime;

      return valid;
    }

    /**
     * Returns true if any Swipe events have been registered
     * @return Boolean
     * @inner
    */
    function hasSwipes() {
      //Enure we dont return 0 or null for false values
      return !!(options.swipe || options.swipeStatus || options.swipeLeft || options.swipeRight || options.swipeUp || options.swipeDown);
    }


    /**
     * Returns true if we are detecting swipes and have one
     * @return Boolean
     * @inner
    */
    function didSwipe() {
      //Enure we dont return 0 or null for false values
      return !!(validateSwipe() && hasSwipes());
    }

        /**
     * Returns true if we have matched the number of fingers we are looking for
     * @return Boolean
     * @inner
    */
        function validateFingers() {
            //The number of fingers we want were matched, or on desktop we ignore
        return ((fingerCount === options.fingers || options.fingers === ALL_FINGERS) || !SUPPORTS_TOUCH);
      }

        /**
     * Returns true if we have an end point for the swipe
     * @return Boolean
     * @inner
    */
        function validateEndPoint() {
            //We have an end value for the finger
        return fingerData[0].end.x !== 0;
        }

    // TAP / CLICK
    /**
     * Returns true if a click / tap events have been registered
     * @return Boolean
     * @inner
    */
    function hasTap() {
      //Enure we dont return 0 or null for false values
      return !!(options.tap) ;
    }

    /**
     * Returns true if a double tap events have been registered
     * @return Boolean
     * @inner
    */
    function hasDoubleTap() {
      //Enure we dont return 0 or null for false values
      return !!(options.doubleTap) ;
    }

    /**
     * Returns true if any long tap events have been registered
     * @return Boolean
     * @inner
    */
    function hasLongTap() {
      //Enure we dont return 0 or null for false values
      return !!(options.longTap) ;
    }

    /**
     * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
     * @return Boolean
     * @inner
    */
    function validateDoubleTap() {
        if(doubleTapStartTime==null){
            return false;
        }
        var now = getTimeStamp();
        return (hasDoubleTap() && ((now-doubleTapStartTime) <= options.doubleTapThreshold));
    }

    /**
     * Returns true if we could be in the process of a double tap (one tap has occurred, we are listening for double taps, and the threshold hasn't past.
     * @return Boolean
     * @inner
    */
    function inDoubleTap() {
        return validateDoubleTap();
    }


    /**
     * Returns true if we have a valid tap
     * @return Boolean
     * @inner
    */
    function validateTap() {
        return ((fingerCount === 1 || !SUPPORTS_TOUCH) && (isNaN(distance) || distance === 0));
    }

    /**
     * Returns true if we have a valid long tap
     * @return Boolean
     * @inner
    */
    function validateLongTap() {
        //slight threshold on moving finger
            return ((duration > options.longTapThreshold) && (distance < DOUBLE_TAP_THRESHOLD));
    }

    /**
     * Returns true if we are detecting taps and have one
     * @return Boolean
     * @inner
    */
    function didTap() {
        //Enure we dont return 0 or null for false values
      return !!(validateTap() && hasTap());
    }


    /**
     * Returns true if we are detecting double taps and have one
     * @return Boolean
     * @inner
    */
    function didDoubleTap() {
        //Enure we dont return 0 or null for false values
      return !!(validateDoubleTap() && hasDoubleTap());
    }

    /**
     * Returns true if we are detecting long taps and have one
     * @return Boolean
     * @inner
    */
    function didLongTap() {
        //Enure we dont return 0 or null for false values
      return !!(validateLongTap() && hasLongTap());
    }




    // MULTI FINGER TOUCH
    /**
     * Starts tracking the time between 2 finger releases, and keeps track of how many fingers we initially had up
     * @inner
    */
    function startMultiFingerRelease() {
      previousTouchEndTime = getTimeStamp();
      previousTouchFingerCount = event.touches.length+1;
    }

    /**
     * Cancels the tracking of time between 2 finger releases, and resets counters
     * @inner
    */
    function cancelMultiFingerRelease() {
      previousTouchEndTime = 0;
      previousTouchFingerCount = 0;
    }

    /**
     * Checks if we are in the threshold between 2 fingers being released
     * @return Boolean
     * @inner
    */
    function inMultiFingerRelease() {

      var withinThreshold = false;

      if(previousTouchEndTime) {
        var diff = getTimeStamp() - previousTouchEndTime
        if( diff<=options.fingerReleaseThreshold ) {
          withinThreshold = true;
        }
      }

      return withinThreshold;
    }


    /**
    * gets a data flag to indicate that a touch is in progress
    * @return Boolean
    * @inner
    */
    function getTouchInProgress() {
      //strict equality to ensure only true and false are returned
      return !!($element.data(PLUGIN_NS+'_intouch') === true);
    }

    /**
    * Sets a data flag to indicate that a touch is in progress
    * @param {boolean} val The value to set the property to
    * @inner
    */
    function setTouchInProgress(val) {

      //Add or remove event listeners depending on touch status
      if(val===true) {
        $element.bind(MOVE_EV, touchMove);
        $element.bind(END_EV, touchEnd);

        //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
        if(LEAVE_EV) {
          $element.bind(LEAVE_EV, touchLeave);
        }
      } else {
        $element.unbind(MOVE_EV, touchMove, false);
        $element.unbind(END_EV, touchEnd, false);

        //we only have leave events on desktop, we manually calcuate leave on touch as its not supported in webkit
        if(LEAVE_EV) {
          $element.unbind(LEAVE_EV, touchLeave, false);
        }
      }


      //strict equality to ensure only true and false can update the value
      $element.data(PLUGIN_NS+'_intouch', val === true);
    }


    /**
     * Creates the finger data for the touch/finger in the event object.
     * @param {int} index The index in the array to store the finger data (usually the order the fingers were pressed)
     * @param {object} evt The event object containing finger data
     * @return finger data object
     * @inner
    */
    function createFingerData( index, evt ) {
      var id = evt.identifier!==undefined ? evt.identifier : 0;

      fingerData[index].identifier = id;
      fingerData[index].start.x = fingerData[index].end.x = evt.pageX||evt.clientX;
      fingerData[index].start.y = fingerData[index].end.y = evt.pageY||evt.clientY;

      return fingerData[index];
    }

    /**
     * Updates the finger data for a particular event object
     * @param {object} evt The event object containing the touch/finger data to upadte
     * @return a finger data object.
     * @inner
    */
    function updateFingerData(evt) {

      var id = evt.identifier!==undefined ? evt.identifier : 0;
      var f = getFingerData( id );

      f.end.x = evt.pageX||evt.clientX;
      f.end.y = evt.pageY||evt.clientY;

      return f;
    }

    /**
     * Returns a finger data object by its event ID.
     * Each touch event has an identifier property, which is used
     * to track repeat touches
     * @param {int} id The unique id of the finger in the sequence of touch events.
     * @return a finger data object.
     * @inner
    */
    function getFingerData( id ) {
      for(var i=0; i<fingerData.length; i++) {
        if(fingerData[i].identifier == id) {
          return fingerData[i];
        }
      }
    }

    /**
     * Creats all the finger onjects and returns an array of finger data
     * @return Array of finger objects
     * @inner
    */
    function createAllFingerData() {
      var fingerData=[];
      for (var i=0; i<=5; i++) {
        fingerData.push({
          start:{ x: 0, y: 0 },
          end:{ x: 0, y: 0 },
          identifier:0
        });
      }

      return fingerData;
    }

    /**
     * Sets the maximum distance swiped in the given direction.
     * If the new value is lower than the current value, the max value is not changed.
     * @param {string}  direction The direction of the swipe
     * @param {int}  distance The distance of the swipe
     * @inner
    */
    function setMaxDistance(direction, distance) {
        distance = Math.max(distance, getMaxDistance(direction) );
        maximumsMap[direction].distance = distance;
    }

        /**
     * gets the maximum distance swiped in the given direction.
     * @param {string}  direction The direction of the swipe
     * @return int  The distance of the swipe
     * @inner
    */
    function getMaxDistance(direction) {
      if (maximumsMap[direction]) return maximumsMap[direction].distance;
      return undefined;
    }

    /**
     * Creats a map of directions to maximum swiped values.
     * @return Object A dictionary of maximum values, indexed by direction.
     * @inner
    */
    function createMaximumsData() {
      var maxData={};
      maxData[LEFT]=createMaximumVO(LEFT);
      maxData[RIGHT]=createMaximumVO(RIGHT);
      maxData[UP]=createMaximumVO(UP);
      maxData[DOWN]=createMaximumVO(DOWN);

      return maxData;
    }

    /**
     * Creates a map maximum swiped values for a given swipe direction
     * @param {string} The direction that these values will be associated with
     * @return Object Maximum values
     * @inner
    */
    function createMaximumVO(dir) {
        return {
            direction:dir,
            distance:0
        }
    }


    //
    // MATHS / UTILS
    //

    /**
    * Calculate the duration of the swipe
    * @return int
    * @inner
    */
    function calculateDuration() {
      return endTime - startTime;
    }

    /**
    * Calculate the distance between 2 touches (pinch)
    * @param {point} startPoint A point object containing x and y co-ordinates
      * @param {point} endPoint A point object containing x and y co-ordinates
      * @return int;
    * @inner
    */
    function calculateTouchesDistance(startPoint, endPoint) {
      var diffX = Math.abs(startPoint.x - endPoint.x);
      var diffY = Math.abs(startPoint.y - endPoint.y);

      return Math.round(Math.sqrt(diffX*diffX+diffY*diffY));
    }

    /**
    * Calculate the zoom factor between the start and end distances
    * @param {int} startDistance Distance (between 2 fingers) the user started pinching at
      * @param {int} endDistance Distance (between 2 fingers) the user ended pinching at
      * @return float The zoom value from 0 to 1.
    * @inner
    */
    function calculatePinchZoom(startDistance, endDistance) {
      var percent = (endDistance/startDistance) * 1;
      return percent.toFixed(2);
    }


    /**
    * Returns the pinch direction, either IN or OUT for the given points
    * @return string Either {@link $.fn.swipe.directions.IN} or {@link $.fn.swipe.directions.OUT}
    * @see $.fn.swipe.directions
    * @inner
    */
    function calculatePinchDirection() {
      if(pinchZoom<1) {
        return OUT;
      }
      else {
        return IN;
      }
    }


    /**
    * Calculate the length / distance of the swipe
    * @param {point} startPoint A point object containing x and y co-ordinates
      * @param {point} endPoint A point object containing x and y co-ordinates
      * @return int
    * @inner
    */
    function calculateDistance(startPoint, endPoint) {
      return Math.round(Math.sqrt(Math.pow(endPoint.x - startPoint.x, 2) + Math.pow(endPoint.y - startPoint.y, 2)));
    }

    /**
    * Calculate the angle of the swipe
    * @param {point} startPoint A point object containing x and y co-ordinates
      * @param {point} endPoint A point object containing x and y co-ordinates
      * @return int
    * @inner
    */
    function calculateAngle(startPoint, endPoint) {
      var x = startPoint.x - endPoint.x;
      var y = endPoint.y - startPoint.y;
      var r = Math.atan2(y, x); //radians
      var angle = Math.round(r * 180 / Math.PI); //degrees

      //ensure value is positive
      if (angle < 0) {
        angle = 360 - Math.abs(angle);
      }

      return angle;
    }

    /**
    * Calculate the direction of the swipe
    * This will also call calculateAngle to get the latest angle of swipe
    * @param {point} startPoint A point object containing x and y co-ordinates
      * @param {point} endPoint A point object containing x and y co-ordinates
      * @return string Either {@link $.fn.swipe.directions.LEFT} / {@link $.fn.swipe.directions.RIGHT} / {@link $.fn.swipe.directions.DOWN} / {@link $.fn.swipe.directions.UP}
    * @see $.fn.swipe.directions
    * @inner
    */
    function calculateDirection(startPoint, endPoint ) {
      var angle = calculateAngle(startPoint, endPoint);

      if ((angle <= 45) && (angle >= 0)) {
        return LEFT;
      } else if ((angle <= 360) && (angle >= 315)) {
        return LEFT;
      } else if ((angle >= 135) && (angle <= 225)) {
        return RIGHT;
      } else if ((angle > 45) && (angle < 135)) {
        return DOWN;
      } else {
        return UP;
      }
    }


    /**
    * Returns a MS time stamp of the current time
    * @return int
    * @inner
    */
    function getTimeStamp() {
      var now = new Date();
      return now.getTime();
    }



    /**
     * Returns a bounds object with left, right, top and bottom properties for the element specified.
     * @param {DomNode} The DOM node to get the bounds for.
     */
    function getbounds( el ) {
      el = $(el);
      var offset = el.offset();

      var bounds = {
          left:offset.left,
          right:offset.left+el.outerWidth(),
          top:offset.top,
          bottom:offset.top+el.outerHeight()
          }

      return bounds;
    }


    /**
     * Checks if the point object is in the bounds object.
     * @param {object} point A point object.
     * @param {int} point.x The x value of the point.
     * @param {int} point.y The x value of the point.
     * @param {object} bounds The bounds object to test
     * @param {int} bounds.left The leftmost value
     * @param {int} bounds.right The righttmost value
     * @param {int} bounds.top The topmost value
    * @param {int} bounds.bottom The bottommost value
     */
    function isInBounds(point, bounds) {
      return (point.x > bounds.left && point.x < bounds.right && point.y > bounds.top && point.y < bounds.bottom);
    };


  }




/**
 * A catch all handler that is triggered for all swipe directions.
 * @name $.fn.swipe#swipe
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */




/**
 * A handler that is triggered for "left" swipes.
 * @name $.fn.swipe#swipeLeft
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */

/**
 * A handler that is triggered for "right" swipes.
 * @name $.fn.swipe#swipeRight
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */

/**
 * A handler that is triggered for "up" swipes.
 * @name $.fn.swipe#swipeUp
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */

/**
 * A handler that is triggered for "down" swipes.
 * @name $.fn.swipe#swipeDown
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user swiped in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */

/**
 * A handler triggered for every phase of the swipe. This handler is constantly fired for the duration of the pinch.
 * This is triggered regardless of swipe thresholds.
 * @name $.fn.swipe#swipeStatus
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {string} phase The phase of the swipe event. See {@link $.fn.swipe.phases}
 * @param {string} direction The direction the user swiped in. This is null if the user has yet to move. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user swiped. This is 0 if the user has yet to move.
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 */

/**
 * A handler triggered for pinch in events.
 * @name $.fn.swipe#pinchIn
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user pinched
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
 */

/**
 * A handler triggered for pinch out events.
 * @name $.fn.swipe#pinchOut
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user pinched
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
 */

/**
 * A handler triggered for all pinch events. This handler is constantly fired for the duration of the pinch. This is triggered regardless of thresholds.
 * @name $.fn.swipe#pinchStatus
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {int} direction The direction the user pinched in. See {@link $.fn.swipe.directions}
 * @param {int} distance The distance the user pinched
 * @param {int} duration The duration of the swipe in milliseconds
 * @param {int} fingerCount The number of fingers used. See {@link $.fn.swipe.fingers}
 * @param {int} zoom The zoom/scale level the user pinched too, 0-1.
 */

/**
 * A click handler triggered when a user simply clicks, rather than swipes on an element.
 * This is deprecated since version 1.6.2, any assignment to click will be assigned to the tap handler.
 * You cannot use <code>on</code> to bind to this event as the default jQ <code>click</code> event will be triggered.
 * Use the <code>tap</code> event instead.
 * @name $.fn.swipe#click
 * @event
 * @deprecated since version 1.6.2, please use {@link $.fn.swipe#tap} instead
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */

 /**
 * A click / tap handler triggered when a user simply clicks or taps, rather than swipes on an element.
 * @name $.fn.swipe#tap
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */

/**
 * A double tap handler triggered when a user double clicks or taps on an element.
 * You can set the time delay for a double tap with the {@link $.fn.swipe.defaults#doubleTapThreshold} property.
 * Note: If you set both <code>doubleTap</code> and <code>tap</code> handlers, the <code>tap</code> event will be delayed by the <code>doubleTapThreshold</code>
 * as the script needs to check if its a double tap.
 * @name $.fn.swipe#doubleTap
 * @see  $.fn.swipe.defaults#doubleTapThreshold
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */

 /**
 * A long tap handler triggered when a user long clicks or taps on an element.
 * You can set the time delay for a long tap with the {@link $.fn.swipe.defaults#longTapThreshold} property.
 * @name $.fn.swipe#longTap
 * @see  $.fn.swipe.defaults#longTapThreshold
 * @event
 * @default null
 * @param {EventObject} event The original event object
 * @param {DomObject} target The element clicked on.
 */

}));

/* **********************************************
     Begin tappy.js
********************************************** */

/*! Tappy! - a lightweight normalized tap event. Copyright 2013 @scottjehl, Filament Group, Inc. Licensed MIT */
(function( w, $, undefined ){

	var tap = function( $els ){
		return $els.each(function(){

			var $el = $( this ),
				lastE,
				resetTimer,
				lastScroll,
				scrollTolerance = 15,
				href;

			function trigger( e ){
				e.preventDefault();
				$( e.target ).trigger( "tap", [ e ] );
			}

			function start(){
				lastScroll = w.document.body.scrollTop;
				if( $el.is( "a" ) ){
					// set href to null hash during tap. this prevents the address bar from dropping down in iOS
					href = $el[ 0 ].href;
					$el[ 0 ].href = "#";
				}
			}

			function end( e ){

				e.preventDefault();

				// this part prevents a double callback from touch and mouse on the same tap
				if( lastE && lastE !== e.type ){
					return false;
				}

				lastE = e.type;
				clearTimeout( resetTimer );
				resetTimer = setTimeout( function(){
					lastE = null;
				}, 1000 );

				// if a scroll happened between touchstart and touchend
				if( e.type === "touchend" && Math.abs( w.document.body.scrollTop - lastScroll ) > scrollTolerance ){
					return false;
				}

				// set href back
				if( href ){
					$el[ 0 ].href = href;
				}
				href = null;

				trigger( e );
			}

			$el
				.bind( "touchstart", start )
				.bind( "touchend", end )
				.bind( "click", end );
		});
	};

	// monkeybind
	var oldBind = $.fn.bind;
	$.fn.bind = function( evt, callback ){
		if( /(^| )tap( |$)/.test( evt ) ){
			tap( this );
		}
		return oldBind.apply( this, [evt, callback] );
	};

}( this, jQuery ));

/* **********************************************
     Begin Site.js
********************************************** */

var Site = Site || {};

// Site namespace
//
// Base namespace for the Site framework
Site.init = (function ($) {
    "use strict";

    var modules = {};
    // Initialisation
    modules.init = function () {
      $(document).ready(function () {
        Site.utils.init();
        Site.layout.init();
        Site.events.init();
        Site.showhide.init();
        Site.forms.init();
        Site.images.init();
        Site.analytics.init();
      });
    };

    // Automatically call init function
    return modules.init();

}(jQuery));

/* **********************************************
     Begin Site.utils.js
********************************************** */

// Site.utils.js

// Check if base namespace is defined
var Site = Site || {};

// Site.helpers namespace
Site.utils = (function ($) {
    "use strict";
    // Variables
    var debugMode = true,
        // Console.log function with check for browsers that don't support it
        logMessage = function (logMessage) {
          if (debugMode === true) {
            if (typeof console !== undefined) {
              console.log(logMessage);
            }
          }
        },

        // Get maximum height of a set of elements
        getMaxHeight = function (elements) {
          var theseElements = elements,
              maxHeight = 0,
              currentHeight = 0;
          $(theseElements).css('min-height', 0);
          $(theseElements).each(function () {
            currentHeight = $(this).height();
            if (currentHeight > maxHeight){
              maxHeight = currentHeight;
            }
          });
          return maxHeight;
        },

        // Equalise the minimum heights of a set of elements
        equaliseMinHeights = function (elements) {
          var theseElements = elements,
              maxHeight = getMaxHeight(theseElements);

          getMaxHeight(theseElements);
          $(theseElements).css('min-height', maxHeight);
        },

        // Check if placeholder attribute is supported
        placeholderIsSupported = function () {
          var test = document.createElement('input');
          return ('placeholder' in test);
        },

        // Read a page's GET URL query string variables and return them as an associative array.
        getURLQueryString = function () {
          var vars = [], hash;
          var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
          for(var i = 0; i < hashes.length; i++)
          {
            hash = hashes[i].split('=');
            vars.push(hash[0]);
            vars[hash[0]] = hash[1];
          }
          return vars;
        },

        // Check if element is currently displayed in the viewport - returns bool
        isElementInView = function (element) {
          var $element = $(element),
              $window = $(window),
              windowHeight = $window.height(),
              scrollTop = $window.scrollTop(),
              elementOffset = $element.offset(),
              top = elementOffset.top;

              if ( (scrollTop + windowHeight) > (top) && (top + $element.height()) > scrollTop ) {
                return true;
              } else {
                return false;
              }
        },

        // Remove the style attribute from an element
        resetStyles = function (element) {
          $(element).removeAttr("style");
        },

        // Add "odd" and "even" classes
        addOddAndEvenClasses = function (elements) {
          var $theseElements = $(elements);
          $theseElements.filter(':nth-child(2n-1)').addClass('odd');
          $theseElements.filter(':nth-child(2n)').addClass('even');

        },

        // Initialisation
        init = function () {
          Site.utils.cl("Site.utils.init called");
        };

    // Return Public API
    return {
      cl: logMessage,
      resetStyles: resetStyles,
      equaliseMinHeights: equaliseMinHeights,
      placeholderIsSupported: placeholderIsSupported,
      getURLQueryString: getURLQueryString,
      isElementInView: isElementInView,
      addOddAndEvenClasses: addOddAndEvenClasses,
      init: init
    };

}(jQuery));


/* **********************************************
     Begin Site.layout.js
********************************************** */

// Site.layout.js

// Check if base layout is defined so it isn't overwritten
var Site = Site || {};

// Create child layout
Site.layout = (function ($) {
  "use strict";
  // Variables
  var defaults = {},
      init = function () {
        Site.utils.cl("Site.layout initialised");
      };

  // Return Public API
  return {
    init: init,
  };
}(jQuery));

/* **********************************************
     Begin Site.showhide.js
********************************************** */

// Site.showhide.js

// Check if base namespace is defined
var Site = Site || {};

// Site.layout namespace
Site.showhide = (function ($) {
    "use strict";
    // Variables
    var defaults = {
          selPlugin : "[data-plugin=showhide]",
          selAction : "[data-action=toggle]",
          selContent : "[data-content=showhide]"
        },

        bindShowHideEvents = function (component, config) {
          var thisComp = component,
              thisAction = $(thisComp).find(defaults.selAction).eq(0),
              thisContent = $(thisComp).find(defaults.selContent).eq(0),
              thisConfig = config || {},
              startState = thisConfig.open || false,
              animate = thisConfig.animate || false,
              speed = thisConfig.speed || 200,

          // Function called when show/hide transition is complete
          transitionComplete = function () {
            // Fire event to be heard by global delegate (Site.events.js)
            $(thisAction).trigger('layoutchange');
          };


          if (startState === false){
            $(thisComp).addClass('isClosed');
          }

          $(thisAction).bind('tap',function (e) {
            e.preventDefault();
            if($(thisComp).hasClass('isClosed')){
              if(animate === true){
                $(thisContent).slideDown(function () {
                  $(thisComp).removeClass('isClosed');
                  transitionComplete();
                });
              } else {
                $(thisContent).show();
                $(thisComp).removeClass('isClosed');
                transitionComplete();
              }

            } else {
              if(animate === true){
                $(thisContent).slideUp(function () {
                  $(thisComp).addClass('isClosed');
                  transitionComplete();
                });
              } else {
                $(thisContent).hide();
                $(thisComp).addClass('isClosed');
                transitionComplete();
              }

            }
          });
        },

        setActiveStates = function (component) {
          var thisComp = component;
          if($(thisComp).find('li a.active').length > 0){
            $(thisComp).addClass('isActive');
          }
        },

        setShowHideComponents = function () {
          var showHideComps = $(defaults.selPlugin);
          $(showHideComps).each(function () {

            var config = $(this).data('plugin-config');

            Site.utils.cl(config);
            setActiveStates(this);
            bindShowHideEvents(this, config);
          });
        },

        // Initialisation
        init = function () {
          Site.utils.cl("Site.showhide.init called");
          setShowHideComponents();
        };

    // Return Public API
    return {
        init: init
    };

}(jQuery));


/* **********************************************
     Begin Site.analytics.js
********************************************** */

// Site.analytics.js

// Check if base namespace is defined
var Site = Site || {};

// Site.analytics namespace
Site.analytics = (function ($) {
    "use strict";
     var defaults = {},

        // Track a virtual page view
        // - handles Asynchronous and Universal Analytics
        trackPageView = function (url) {
          var thisURL = url;

          if (typeof ga !== 'undefined'){ // Using Google Universal Analytics

            ga('send','pageview',thisURL);

            /*
            Site.utils.cl("Page view tracked");
            Site.utils.cl('Tracked URL:');
            Site.utils.cl(thisURL);
            */

          } else if (typeof _gaq !== 'undefined'){ // Using Asynchronous Analytics

            _gaq.push(['trackPageview'], url);

            /*
            Site.utils.cl("Page view tracked");
            Site.utils.cl('Tracked URL:');
            Site.utils.cl(thisURL);
            */

          } else {

            /*
            Site.utils.cl('Tracked URL:');
            Site.utils.cl(thisURL);
            */

            Site.utils.cl("Google Analytics not available");
          }
        },

        // Track an in-page event
        // - handles Asynchronous and Universal Analytics
        trackPageEvent = function (category, eventType, detail) {
          var thisCategory = category,
              thisEventType = eventType,
              thisDetail = detail;

              if(typeof ga !== 'undefined'){ // Using Google Universal Analytics

                ga('send', 'event' , thisCategory, thisEventType, thisDetail);

                /*
                Site.utils.cl("Page Event tracked");
                Site.utils.cl('Event Category:');
                Site.utils.cl(thisCategory);
                Site.utils.cl('Event Type:');
                Site.utils.cl(thisEventType);
                Site.utils.cl('Event Detail:');
                Site.utils.cl(thisDetail);
                */

              } else if (typeof _gaq !== 'undefined'){ // Using Asynchronous Analytics

                _gaq.push(['_trackEvent', thisCategory, thisEventType, thisDetail]);

                /*
                Site.utils.cl("Page Event tracked");
                Site.utils.cl('Event Category:');
                Site.utils.cl(thisCategory);
                Site.utils.cl('Event Type:');
                Site.utils.cl(thisEventType);
                Site.utils.cl('Event Detail:');
                Site.utils.cl(thisDetail);
                */

              } else {

                /*
                Site.utils.cl("Page Event tracked");
                Site.utils.cl('Event Category:');
                Site.utils.cl(thisCategory);
                Site.utils.cl('Event Type:');
                Site.utils.cl(thisEventType);
                Site.utils.cl('Event Detail:');
                Site.utils.cl(thisDetail);
                */

                Site.utils.cl("Google Analytics not available");
              }
        },

        // Track PDF views, passing the path to the PDF as the URL
        trackPDFLinks = function () {
          $("a[href$='pdf']").on('click', function () {
            Site.utils.cl('PDF link tracked');
            var thisURL = $(this).attr('href');
            trackPageView(thisURL);
          });
        },

        // Set Custom variable for Responsive Design layout
        trackPageLayout = function () {

          var screenWidth = $(window).width(),
              layoutCategory;

          //Site.utils.cl(screenWidth);

          // Custom set of conditions to set variable value
          if (screenWidth > 768 ) {
            layoutCategory = "Desktop";
          } else if (screenWidth > 520) {
            layoutCategory = "Tablet";
          } else {
            layoutCategory = "Phone";
          }

          //Site.utils.cl(layoutCategory);

          if (ga !== 'undefined') {
            // This needs to be configured to match the Custom Dimension setup
            // in your Universal Analytics account
            ga('set', 'dimension1', layoutCategory);
            //Site.utils.cl("Layout custom dimension set for this page view (Universal Analytics)");

          } else if (typeof _gaq !== 'undefined') {
            _gaq.push(['_setCustomVar', 1 , 'Layout', layoutCategory, 3]);
            //Site.utils.cl("Layout custom variable set for this page view (Trad Analytics)");
          } else {
            //Site.utils.cl('Google Analytics not available');
          }

          //Site.utils.cl("Breakpoint custom variable set for this page view");
        },

        // Call custom functions before standard Page View call is made
        // - e.g. Set Custom variables to pass to server with page view call
        // This function should be called before the default 'trackPageView' function
        // call in the on-page Google Analytics script
        trackPageLoadInformation = function () {
          // Call custom functions
          trackPageLayout();
        },

        // Initialisation
        init = function () {
            Site.utils.cl("Site.analytics.init called");
            trackPDFLinks();
        };

    // Return Public API
    return {
      init: init,
      trackPageView: trackPageView,
      trackPageEvent: trackPageEvent,
      trackPageLoadInformation: trackPageLoadInformation
    };
}(jQuery));


/* **********************************************
     Begin Site.events.js
********************************************** */

// Site.events.js

// Check if base namespace is defined so it isn't overwritten
var Site = Site || {};

// Create child namespace
Site.events = (function ($) {
    "use strict";
    // Variables
    var defaults = {},
        /* Use fastclick plugin to remove tap delay on touch devices */
        setFastTapEvents = function () {
          if(FastClick){
            FastClick.attach(document.body);
          }
        },

        // Bind delegate events
        bindDelegateEvents = function () {
          var $body = $('body');

          // Handle 'layoutChange' event bubbled to <body> element
          $body.on('layoutchange', function () {
            Site.utils.cl('layoutchange on body');

            // Update any lazy-load images that may now be visible
            if(Site.images.updateLazyImages !== undefined) {
              Site.images.updateLazyImages();
            }
          });
        },

        init = function () {
          Site.utils.cl("Site.events initialised");
          //setFastTapEvents();
          bindDelegateEvents();
        };

    // Return Public API
    return {
      init: init
    };

}(jQuery));

/* **********************************************
     Begin Site.forms.js
********************************************** */

// Site.namespace.js

// Check if base namespace is defined so it isn't overwritten
var Site = Site || {};

// Create child namespace
Site.forms = (function ($) {
    "use strict";
    // Variables
    var isPlaceholderSupported = Site.utils.placeholderIsSupported(),

        // Set placeholder attribute using label text
        setPlaceholders = function () {
          $('.form-item').each(function(){
            var formElem = $(this).find('input, textarea').not('input[type=submit]').eq(0),
                formLabel = $(this).find('label').eq(0),
                formLabelText = $(formLabel).text(),
                mandSpan = $(formLabelText).find('.form-required');
                formLabelText = $(formLabel).text();
                $(formElem).attr('placeholder', formLabelText);
          });

          // Now the placeholders have been set, make sure the fallback is in place for
          // browsers that don't have native support for the attribute
          if(!isPlaceholderSupported){
            setPlaceholderFallback();
          }
        },

        // Add placeholder-like behaviour for form fields in browsers that don't support it
        setPlaceholderFallback = function () {
          // Create default text for text field on page load
          createText = function (defVal, thisObj) {
            if (thisObj.attr("value") === defVal || thisObj.attr("value").length === 0) {
              thisObj.attr("value", defVal);
              thisObj.addClass("empty");
            }
          },

          // Remove default text on focus. Ignore user-inserted text
          removeText = function (defVal, thisObj) {
            var currVal = thisObj.attr("value");
            if (currVal === defVal) {
              thisObj.attr("value", "");
              thisObj.removeClass("empty");
            }
          },

          // Restore default text on focus. Ignore user-inserted text
          restoreText = function (defVal, thisObj) {
            var currVal = thisObj.attr("value");
            if (currVal !== undefined && currVal !== '') {
              thisObj.attr("value", currVal);
            }
            else if (currVal === undefined || currVal === '') {
              thisObj.attr("value", defVal);
              thisObj.addClass("empty");
            }
          };

          Site.utils.cl(isPlaceholderSupported);

          if (!isPlaceholderSupported){

            Site.utils.cl('Placeholder not supported');
            // Get inputs with a placeholder attribute set
          	$("input[placeholder], textarea[placeholder]").each(function() {
              var labelVal = $(this).attr("placeholder");
              $(this).each(function() {
                  createText(labelVal, $(this));
              });
              // Removal of text on user-focus
              $(this).focus(function() {
                  removeText(labelVal, $(this));
              });
              // Restoration of default text on input blur, if no user input.
              $(this).blur(function() {
                  restoreText(labelVal, $(this));
              });
            });
          }
        },

        init = function () {
          Site.utils.cl("Site.forms initialised");
        };

    // Return Public API
    return {
      init: init
    };

}(jQuery));

/* **********************************************
     Begin Site.images.js
********************************************** */

// Site.images.js

// Check if base namespace is defined so it isn't overwritten
var Site = Site || {};

// Create child namespace
Site.images = (function ($) {
  "use strict";
  // Variables
  var defaults = { },
      $lazyLoadImages = $('.lazyLoader'),

      // Display a pre-loaded lazy image, adding atrributes set on
      // the sprite container
      displaySpriteImageInContainer = function (container, image) {
        var $thisContainer = $(container),
            $thisImage = $(image),
            imageAlt = $thisContainer.data('alt') || 'image',
            imageWidth = $thisContainer.data('width') || '';

        $thisImage.attr('width', imageWidth).attr('alt', imageAlt);
        $thisContainer.prepend($thisImage).addClass('imageLoaded');
        // Need to allow browser a moment to process the addition of the image before diplaying it
        window.setTimeout(function () {$thisContainer.addClass('imageDisplayed');}, 100);
        Site.utils.cl("Image loaded and displayed");
      },

      // Create and preload a new image based on a sprite src
      // then call a function once the image is loaded into memory
      getSpriteImageFile = function (sprite) {
        var $thisSprite = sprite,
            thisImageUrl = $thisSprite.data('src'),
            imageToAdd = new Image();

            imageToAdd.src = thisImageUrl;
            $(imageToAdd).imagesLoaded(displaySpriteImageInContainer($thisSprite, imageToAdd));
      },

      loadSpriteImageIfInView = function (sprite) {
        var $thisSprite = sprite;
        if(Site.utils.isElementInView($thisSprite)){
          getSpriteImageFile($thisSprite);
        }
      },

      // lazyImage class
      buildLazyImage = function (sprite) {
        var $thisSprite = $(sprite),
            loadingMethod = $thisSprite.data('loading');

        if(loadingMethod === 'click') {
          $thisSprite.bind('tap', function () {
            if (!$thisSprite.hasClass('imageLoaded')) {
              getSpriteImageFile($thisSprite);
            }
          });
        }
        // If image is set to display when container is in view
        else if (loadingMethod === 'view') {
          // Load image if it is in view
          loadSpriteImageIfInView($thisSprite);

          // Load image if it comes into view on scroll or window resize
          $(window).on('scroll debouncedresize', function () {
            if (!$thisSprite.hasClass('imageLoaded')) {
              loadSpriteImageIfInView($thisSprite);
            }
          });
        }
        // Otherwise load the image on page load
        else {
          getSpriteImageFile($thisSprite);
        }

        // Bind to custom event so we can load any images moved into view when e.g. a show/hide control is closed/opened
        $thisSprite.on('layoutUpdate', function () {
          Site.utils.cl('listening for layoutUpdate event');
          loadSpriteImageIfInView($thisSprite);
        });
      },

      // Set up all lazy images on the page
      buildLazyImages = function () {
        $lazyLoadImages.each(function () {
          buildLazyImage(this);
        });
      },

      // Exposed function to update images when the page layout changes
      // - checks if image is loaded already
      updateLazyImages = function () {
        $lazyLoadImages.each(function () {
          var $thisSprite = $(this);
          if(!$thisSprite.hasClass('imageLoaded') && $thisSprite.data('loading') === 'view' ) {
            $thisSprite.trigger('layoutUpdate');
          }
        });
      },

      init = function () {
        Site.utils.cl("Site.images initialised");
        buildLazyImages();
      };

  // Return Public API
  return {
    init: init,
    updateLazyImages: updateLazyImages
  };

}(jQuery));